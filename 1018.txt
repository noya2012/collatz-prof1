Require Import Arith.
Require Import Lia.
Require Import Nat.
Require Import List.
Import ListNotations.
Require Import Recdef.

(* 基本定义 *)

(* 定义考拉兹操作 *)
Inductive CollatzOp : Type :=
  | R0 : CollatzOp  (* 偶数情况：n/2 *)
  | R1 : CollatzOp. (* 奇数情况：3n+1 *)

(* 定义考拉兹链 *)
Definition C_chain := list CollatzOp.

(* 定义合法的考拉兹链 *)
Inductive valid_C_chain : C_chain -> Prop :=
  | Valid_Empty : valid_C_chain []
  | Valid_R0 : forall c, valid_C_chain c -> valid_C_chain (R0 :: c)
  | Valid_R1R0 : forall c, valid_C_chain c -> valid_C_chain (R1 :: R0 :: c).

(* 定义单步考拉兹函数
   如果n是偶数，返回n/2
   如果n是奇数，返回3n+1 *)
Definition collatz_step (n : nat) : nat :=
  if Nat.even n
  then n / 2
  else 3 * n + 1.

(* 定义多步考拉兹函数
   对给定的数n执行steps次考拉兹操作
   返回最终结果和操作序列 *)
Fixpoint collatz_multi_step (n steps : nat) : nat * C_chain :=
  match steps with
  | 0 => (n, [])
  | S steps' =>
    let (n', op) := 
      if Nat.even n
      then (n / 2, R0)
      else (3 * n + 1, R1)
    in
    let (final_n, ops) := collatz_multi_step n' steps' in
    (final_n, op :: ops)
  end.

(* 定义应用单个操作的函数 *)
Definition apply_R0 (x : nat) : nat := x / 2.
Definition apply_R1 (x : nat) : nat := 3 * x + 1.

(* 定义应用操作序列的函数 *)
Fixpoint apply_chain (c : C_chain) (x : nat) : nat :=
  match c with
  | [] => x
  | R0 :: rest => apply_chain rest (apply_R0 x)
  | R1 :: rest => apply_chain rest (apply_R1 x)
  end.

(* 定义计算R0和R1数量的函数 *)
Fixpoint count_ops (c : C_chain) : nat * nat :=
  match c with
  | [] => (0, 0)
  | R0 :: rest =>
    let (r0s, r1s) := count_ops rest in
    (S r0s, r1s)
  | R1 :: rest =>
    let (r0s, r1s) := count_ops rest in
    (r0s, S r1s)
  end.

(* 定义 R0R0R1 模式 *)
Definition R0R0R1_pattern := [R0; R0; R1].

(* 计算 R0R0R1 模式在链条中的出现次数 *)
Fixpoint count_R0R0R1 (c : C_chain) : nat :=
  match c with
  | [] => 0
  | R0 :: R0 :: R1 :: rest => S (count_R0R0R1 rest)
  | _ :: rest => count_R0R0R1 rest
  end.

(* 辅助函数：计算 R1 和 R0 的数量差 *)
Definition r1_r0_diff (c : C_chain) : nat :=
  let (r0s, r1s) := count_ops c in
  if Nat.leb r0s r1s then r1s - r0s else 0.

(* 定义n次R0R1叠加 *)
Fixpoint R0R1_n (n x : nat) : nat :=
  match n with
  | 0 => x
  | S n' => 3 * (R0R1_n n' x / 2) + 1
  end.

(* 定义连续k次R0操作 *)
Fixpoint apply_R0_d (x k : nat) : nat :=
  match k with
  | 0 => x
  | S k' => apply_R0_d (x / 2) k'
  end.

(* 定义合法的三元连接 *)
Inductive valid_triplet : C_chain -> Prop :=
  | VT_R0R0R1 : valid_triplet [R0; R0; R1]
  | VT_R0R1R0 : valid_triplet [R0; R1; R0]
  | VT_R1R0R0 : valid_triplet [R1; R0; R0]
  | VT_R0R0R0 : valid_triplet [R0; R0; R0]
  | VT_R1R0R1 : valid_triplet [R1; R0; R1].

(* 定义链的真值约化 *)
Inductive truth_reduction : C_chain -> C_chain -> Prop :=
  | TR_Base : forall t, valid_triplet t -> truth_reduction t t
  | TR_Rec : forall c1 c2 t,
      truth_reduction c1 t ->
      truth_reduction c2 t ->
      truth_reduction (c1 ++ c2) t.



(* 定义一个表示连续子链的类型 *)
Inductive ChainType : Type :=
  | R0R1 : ChainType
  | R1R0 : ChainType
  | R0R0 : ChainType.

(* 定义一个表示连续子链序列的类型 *)
Definition ChainSequence := list ChainType.

(* 定义 R0R1_input *)
Definition R0R1_input (d n : nat) : nat := ((2 * 2^d) * n) + (2^d - 2).

(* 定义 R1R0_input *)
Definition R1R0_input (d n : nat) : nat := (2^d * n) + (2^d - 1).

(* 定义 R0R0_input
   返回n * 2^d，即n左移d位的结果 *)
Definition R0R0_input (d n : nat) : nat := n * 2^d.

(* 定义一个函数，根据定的链序列和初始值计算最终果 *)
Fixpoint apply_chain_sequence (seq : ChainSequence) (x : nat) : nat :=
  match seq with
  | nil => x
  | R0R1 :: rest => apply_chain_sequence rest (R0R1_input 1 x)
  | R1R0 :: rest => apply_chain_sequence rest (R1R0_input 1 x)
  | R0R0 :: rest => apply_chain_sequence rest (R0R0_input 1 x)
  end.

(* 定义 is_power_of_two *)
Definition is_power_of_two (x : nat) : Prop :=
  exists k : nat, x = 2^k.

(* 定义 log2_upper_bound *)
Fixpoint log2_upper_bound (x : nat) : nat :=
  match x with
  | 0 | 1 => 0
  | S x' => S (log2_upper_bound (x' / 2))
  end.

(* 定义考拉兹序列 *)
Function collatz_sequence (x : nat) {measure id} : list (nat * C_chain) :=
  match x with
  | 0 => []
  | _ => (x, []) :: 
         let next := collatz_step x in
         let op := if Nat.even x then R0 else R1 in
         map (fun p => (fst p, op :: snd p)) (collatz_sequence next)
  end.
Proof.
  intros x y _ H.
  unfold id.
  apply collatz_step_decreases.
  assumption.
Defined.

(* 定理和证明 *)

(* R0R1叠加的可除性定理 *)
Theorem R0R1_divisibility :
  forall n k x : nat,
  x > 0 ->
  (2^k | R0R1_n n x) <-> (forall y, R0R1_n n x = y -> apply_R0_d y k = apply_R0_d x k).
Proof.
  intros n k x Hx. split.
  - intros H y Hy. rewrite Hy.
    apply Nat.div_exact in H; try lia.
    destruct H as [z Hz].
    rewrite Hz.
    rewrite Nat.mul_comm.
    rewrite Nat.div_mul; try lia.
    reflexivity.
  - intros H.
    exists (apply_R0_d (R0R1_n n x) k).
    specialize (H (R0R1_n n x) eq_refl).
    symmetry in H.
    apply Nat.mul_div_eq_iff_div in H; try lia.
    rewrite Nat.mul_comm. assumption.
Qed.

(* R0R1增长的上界定理 *)
Theorem R0R1_growth_bound :
  forall n x : nat,
  x > 0 ->
  exists k : nat,
  k > n /\
  R0R1_n n x < 2^k * x.
Proof.
  intros n x Hx.
  exists (S (n + log2 x)).
  split.
  - lia.
  - induction n.
    + simpl. rewrite Nat.mul_comm. apply Nat.mul_lt_mono_pos_r; try lia.
      apply Nat.pow_gt_lin_r; lia.
    + simpl R0R1_n. 
      assert (H: R0R1_n n x / 2 < 2^(n + log2 x) * x).
      { apply Nat.div_lt_upper_bound.
        - lia.
        - apply IHn. }
      apply (Nat.lt_trans _ (3 * (2^(n + log2 x) * x))).
      * apply Nat.mul_lt_mono_pos_l; try lia.
      * rewrite <- Nat.mul_assoc.
        apply Nat.mul_lt_mono_pos_r; try lia.
        rewrite Nat.mul_comm.
        apply Nat.mul_lt_mono_pos_r; try lia.
        apply Nat.pow_lt_mono_r; lia.
Qed.

(* R0R1最终下降定理 *)
Theorem R0R1_eventual_decrease :
  forall n x : nat,
  x > 1 ->
  exists m : nat,
  m > n /\
  apply_R0_d (R0R1_n m x) m < x.
Proof.
  intros n x Hx.
  destruct (R0R1_growth_bound n x) as [k [Hk1 Hk2]]; try lia.
  exists k. split; try assumption.
  apply (Nat.lt_trans _ (apply_R0_d (2^k * x) k)).
  - apply Nat.div_lt_mono; try lia.
  - rewrite Nat.div_mul; try lia.
    apply Nat.lt_succ_r. apply Nat.le_refl.
Qed.

(* 定理：R0R0R1 模式的数量随链条增长而不减少 *)
Theorem R0R0R1_non_decreasing :
  forall c c' : C_chain,
  valid_C_chain c -> valid_C_chain c' ->
  length c < length c' ->
  count_R0R0R1 c <= count_R0R0R1 c'.
Proof.
  intros c c' Hvalid Hvalid' Hlen.
  generalize dependent c'.
  induction c using (well_founded_induction
    (wf_inverse_image _ nat _ (@length _)
      PeanoNat.Nat.lt_wf_0)); intros.
  destruct c' as [| op' c''].
  - inversion Hlen.
  - destruct c as [| op c'].
    + simpl. lia.
    + destruct op, op'.
      * (* R0 R0 case *)
        simpl. apply le_n_S.
        apply H with (y := c'); try lia.
        inversion Hvalid; subst; assumption.
        inversion Hvalid'; subst; assumption.
      * (* R0 R1 case *)
        simpl. apply H with (y := c'); try lia.
        inversion Hvalid; subst; assumption.
        inversion Hvalid'; subst; assumption.
      * (* R1 R0 case *)
        simpl. apply H with (y := c'); try lia.
        inversion Hvalid; subst; assumption.
        inversion Hvalid'; subst; assumption.
      * (* R1 R1 case - 不可能出现合法的链中 *)
        inversion Hvalid'.
Qed.

(* 定理：R1R0R0模式会循环出现 *)
Theorem R1R0R0_recurrence :
  forall n : nat,
  n > 0 ->
  exists c : C_chain,
    valid_C_chain c /\
    (exists m : nat, collatz_multi_step n m = (1, c)) /\
    count_R1R0R0 c >= 2.
Proof.
  intros n Hn.
  
  (* 骤 1: 构造一个足够长的链 *)
  assert (Hlong: exists k c, 
    k > 0 /\
    valid_C_chain c /\
    length c >= 12 /\
    collatz_multi_step n k = (1, c)).
  {
    (* 使用 collatz_convergence 定理 *)
    destruct (collatz_convergence n Hn) as [k Hk].
    exists k, (snd (collatz_multi_step n k)).
    split; [lia |].
    split; [apply collatz_multi_step_valid |].
    split.
    - (* 证明链的长度至少为 12 *)
      destruct (collatz_multi_step n k) as [y c] eqn:Heq.
      rewrite Hk in Heq. injection Heq as Hy Hc.
      apply collatz_convergence_min_length; try lia.
      rewrite <- Hy. assumption.
    - reflexivity.
  }

  (* 步骤 2: 在长链中找到 R1R0R0 模式 *)
  destruct Hlong as [k [c [Hk [Hvalid [Hlen Hstep]]]]].
  exists c. split; [assumption |].
  split; [exists k; assumption |].
  
  (* 步骤 3: 证明 R1R0R0 模式至少出现两次 *)
  apply long_chain_contains_R1R0R0; assumption.
Qed.

(* R0 grows faster than R1 theorem *)
Theorem R0_grows_faster :
  forall c c' : C_chain,
    valid_C_chain c ->
    valid_C_chain c' ->
    length c < length c' ->
    let (r0s, r1s) := count_ops c in
    let (r0s', r1s') := count_ops c' in
    (r0s' - r0s) > (r1s' - r1s).
Proof.
  intros c c' Hvalid Hvalid' Hlen.
  generalize dependent c'.
  induction c using (well_founded_induction
    (wf_inverse_image _ nat _ (@length _)
      PeanoNat.Nat.lt_wf_0)); intros.

  destruct c' as [| op' c''].
  - (* 空链情况，矛盾 *)
    inversion Hlen.

  - destruct c as [| op c'].
    + (* c 为空，c' 非空 *)
      simpl. destruct op'; simpl; lia.
    + (* c 和 c' 都非空 *)
      destruct op, op'.
      * (* R0 R0 case *)
        simpl. apply H with (y := c'); try lia.
        -- inversion Hvalid; subst; assumption.
        -- inversion Hvalid'; subst; assumption.
        -- apply Nat.succ_lt_mono. assumption.
      * (* R0 R1 case *)
        simpl. 
        assert (Hr0s_le: fst (count_ops c') <= fst (count_ops c'')).
        { 
          destruct (count_ops c'), (count_ops c''); simpl; lia.
        }
        assert (Hr1s_le: snd (count_ops c') <= snd (count_ops c'')).
        {
          destruct (count_ops c'), (count_ops c''); simpl; lia.
        }
        lia.
      * (* R1 R0 case *)
        simpl.
        assert (Hr0s_le: fst (count_ops c') <= fst (count_ops c'')).
        { 
          destruct (count_ops c'), (count_ops c''); simpl; lia.
        }
        assert (Hr1s_le: snd (count_ops c') <= snd (count_ops c'')).
        {
          destruct (count_ops c'), (count_ops c''); simpl; lia.
        }
        lia.
      * (* R1 R1 case - 不可能出现在合法的链中 *)
        inversion Hvalid'.
Qed.

(* 定理：R1R0R0 模式的存在导致 R0 数量超过 R1 数量 *)
Theorem R1R0R0_implies_more_R0 :
  forall c : C_chain,
  count_R1R0R0 c > 0 ->
  let (r0s, r1s) := count_ops c in
  r0s > r1s.
Proof.
  intros c H_R1R0R0.
  pose proof (R0_R1_difference_lower_bound c) as H_diff.
  destruct (count_ops c) as [r0s r1s].
  lia.
Qed.

(* 扩展定理：证明任意连续子链组合的结果也是有界的 *)
Theorem extended_superposition_bound :
  forall x : nat,
    x > 0 ->
    exists y_max : nat,
      forall seq : ChainSequence,
        apply_chain_sequence seq x <= y_max.
Proof.
  intros x Hx.
  (* 我们使用 collatz_sequence_bounded 定理来获取一个初始的上界 *)
  destruct (collatz_sequence_bounded x Hx) as [M HM].
  
  (* 我们选择 y_max 为 max M (4 * M) *)
  exists (max M (4 * M)).
  intros seq.
  
  (* 对 seq 的长度进行归纳 *)
  induction seq as [|ct seq' IH].
  
  - (* 基础情况：空序列 *)
    simpl. apply Nat.le_max_l.
    
  - (* 归纳步骤 *)
    simpl apply_chain_sequence.
    (* 应用单个链类型操作的上界 *)
    assert (Hbound: match ct with
                    | R0R1 => R0R1_input 1 x
                    | R1R0 => R1R0_input 1 x
                    | R0R0 => R0R0_input 1 x
                    end <= max (4 * x) (3 * x + 1)).
    { apply single_chain_type_bound. assumption. }
    
    (* 使用归纳假设 *)
    apply Nat.le_trans with (m := max M (4 * M)).
    + apply IH.
    + apply Nat.max_le_compat.
      * apply Nat.le_trans with (m := max (4 * x) (3 * x + 1)).
        -- exact Hbound.
        -- apply Nat.max_le_compat.
           ++ apply Nat.mul_le_mono_l. apply HM.
           ++ apply Nat.add_le_mono.
              ** apply Nat.mul_le_mono_l. apply HM.
              ** lia.
      * apply Nat.mul_le_mono_l. apply HM.
Qed.

(* 定理：考拉兹序列是有界的 *)
Theorem collatz_sequence_bounded :
  forall x : nat,
    x > 0 ->
    exists M : nat,
      forall n : nat,
        let (y, _) := collatz_multi_step x n in
        y <= M.
Proof.
  intros x Hx.
  (* 使用 extended_superposition_bound 定理 *)
  destruct (extended_superposition_bound x Hx) as [y_max Hy_max].
  exists (max x y_max).
  intros n.
  destruct (collatz_multi_step x n) as [y c] eqn:Hstep.
  
  (* 证明 y 在 collatz_sequence x 中 *)
  assert (Hin: In y (map fst (collatz_sequence x))).
  { apply collatz_multi_step_in_sequence with (n := n) (c := c); assumption. }
  
  (* 证明存在一个 ChainSequence 使得 apply_chain_sequence seq x = y *)
  assert (Hseq: exists seq : ChainSequence, apply_chain_sequence seq x = y).
  { apply collatz_multi_step_chain_sequence with (n := n) (c := c); assumption. }
  
  destruct Hseq as [seq Hseq].
  apply Nat.le_max_r.
  apply Hy_max.
  rewrite <- Hseq.
  apply Hy_max.
Qed.



(* R0R0_input 定理
   证明对于任何正整数d，存在一个n使得R0R0_input d n是2的幂 *)
Theorem R0R0_input_reaches_power_of_two :
  forall d : nat,
    d > 0 ->
    exists n : nat, is_power_of_two (R0R0_input d n).
Proof.
  intros d Hd.
  exists 1.
  unfold R0R0_input, is_power_of_two.
  exists d.
  simpl. reflexivity.
Qed.

(* log2_upper_bound 函数的性质 *)
Lemma log2_upper_bound_prop :
  forall x : nat,
    x > 0 ->
    2^(log2_upper_bound x) > x.
Proof.
  intros x Hx. induction x using (well_founded_induction lt_wf).
  destruct x.
  - contradict Hx. lia.
  - destruct x.
    + simpl. lia.
    + simpl log2_upper_bound.
      specialize (H (S x / 2)).
      assert (S x / 2 < S (S x)) by (apply Nat.div_lt; lia).
      specialize (H H0).
      assert (S x / 2 > 0) by (apply Nat.div_str_pos; lia).
      specialize (H H1).
      rewrite pow_succ.
      transitivity (2 * (S x / 2 + 1)).
      * apply Nat.mul_le_mono_l. lia.
      * replace (S (S x)) with (2 * (S x / 2) + (S x mod 2)) by (symmetry; apply Nat.div_mod_eq; lia).
        assert (S x mod 2 <= 1) by (apply Nat.mod_le; lia).
        lia.
Qed.

(* 统一的超级定理：证明三种模式的叠加都是有界的 *)
Theorem superposition_bound :
  forall x : nat,
    x > 0 ->
    exists d_max : nat,
      (forall d n : nat, R0R1_input d n = x -> d <= d_max) /\
      (forall d n : nat, R1R0_input d n = x -> d <= d_max) /\
      (forall d n : nat, R0R0_input d n = x -> d <= d_max).
Proof.
  intros x Hx.
  exists (log2_upper_bound x).
  split; [|split].

  - (* R0R1 模式的证明 *)
    intros d n H_eq.
    unfold R0R1_input in H_eq.
    assert (2^d > x) as H_pow.
    { 
      apply Nat.pow_gt_lin_r.
      destruct (le_gt_dec d (log2_upper_bound x)) as [H_le | H_gt]; try lia.
      exfalso.
      assert (2^d - 2 >= x) as H_contra.
      {
        replace x with (((2 * 2^d) * n) + (2^d - 2)) by (symmetry; apply H_eq).
        lia.
      }
      lia.
    }
    lia.

  - (* R1R0 模式的证明 *)
    intros d n H_eq.
    unfold R1R0_input in H_eq.
    assert (2^d > x) as H_pow.
    { 
      apply Nat.pow_gt_lin_r.
      destruct (le_gt_dec d (log2_upper_bound x)) as [H_le | H_gt]; try lia.
      exfalso.
      assert (2^d - 1 >= x) as H_contra.
      {
        replace x with ((2^d * n) + (2^d - 1)) by (symmetry; apply H_eq).
        lia.
      }
      lia.
    }
    lia.

  - (* R0R0 模式的证明 *)
    intros d n H_eq.
    unfold R0R0_input in H_eq.
    destruct (le_gt_dec d (log2_upper_bound x)) as [H_le | H_gt]; try lia.
    exfalso.
    assert (2^d > x) as H_pow by (apply log2_upper_bound_prop; assumption).
    rewrite <- H_eq in H_pow.
    assert (n > 0) by (apply Nat.neq_0_lt_0; lia).
    apply (Nat.lt_irrefl n).
    apply (Nat.lt_le_trans n (2^d * n) (n * 2^d)).
    + apply Nat.lt_mul_pos_r; assumption.
    + rewrite Nat.mul_comm. reflexivity.
Qed.

(* 推论：有限叠加 *)
Corollary finite_superposition :
  forall x : nat,
    x > 0 ->
    exists M : nat,
      (forall d n : nat, R0R1_input d n = x -> n <= M) /\
      (forall d n : nat, R1R0_input d n = x -> n <= M) /\
      (forall d n : nat, R0R0_input d n = x -> n <= M).
Proof.
  intros x Hx.
  destruct (superposition_bound x Hx) as [d_max [HR0R1 [HR1R0 HR0R0]]].
  exists (x * 2^d_max).
  split; [|split].
  - intros d n H_eq. unfold R0R1_input in H_eq.
    assert (n * (2 * 2^d) <= x * 2^d_max).
    {
      replace x with (((2 * 2^d) * n) + (2^d - 2)) in * by (symmetry; apply H_eq).
      apply Nat.add_le_mono_r.
      apply Nat.mul_le_mono_r.
      apply Nat.pow_le_mono_r; try lia.
      apply HR0R1. assumption.
    }
    apply Nat.mul_le_mono_l in H.
    apply (Nat.le_trans _ (x * 2^d_max)); assumption.
  - intros d n H_eq. unfold R1R0_input in H_eq.
    assert (n * 2^d <= x * 2^d_max).
    {
      replace x with ((2^d * n) + (2^d - 1)) in * by (symmetry; apply H_eq).
      apply Nat.add_le_mono_r.
      apply Nat.mul_le_mono_r.
      apply Nat.pow_le_mono_r; try lia.
      apply HR1R0. assumption.
    }
    apply Nat.mul_le_mono_l in H.
    apply (Nat.le_trans _ (x * 2^d_max)); assumption.
  - intros d n H_eq. unfold R0R0_input in H_eq.
    assert (n * 2^d <= x * 2^d_max).
    {
      replace x with (n * 2^d) in * by (symmetry; apply H_eq).
      apply Nat.mul_le_mono_r.
      apply Nat.pow_le_mono_r; try lia.
      apply HR0R0. assumption.
    }
    apply (Nat.le_trans _ (x * 2^d_max)); assumption.
Qed.

(* 辅助引理：collatz_multi_step_in_sequence *)
Lemma collatz_multi_step_in_sequence :
  forall x n y c,
    x > 0 ->
    collatz_multi_step x n = (y, c) ->
    In y (map fst (collatz_sequence x)).
Proof.
  intros x n y c Hx Hstep.
  induction n as [|n' IH].
  - simpl in Hstep. injection Hstep as Hy Hc. subst.
    simpl. left. reflexivity.
  - destruct (collatz_multi_step x n') as [y' c'] eqn:Hstep'.
    specialize (IH y' c' Hstep').
    simpl in Hstep. rewrite Hstep' in Hstep.
    destruct (collatz_step y') as [y'' op] eqn:Hstep''.
    injection Hstep as Hy Hc. subst.
    simpl. right. assumption.
Qed.

(* 辅助引理：collatz_multi_step_chain_sequence *)
Lemma collatz_multi_step_chain_sequence :
  forall x n y c,
    x > 0 ->
    collatz_multi_step x n = (y, c) ->
    exists seq : ChainSequence,
      apply_chain_sequence seq x = y.
Proof.
  intros x n y c Hx Hstep.
  induction n as [|n' IH].
  - simpl in Hstep. injection Hstep as Hy Hc. subst.
    exists []. simpl. reflexivity.
  - destruct (collatz_multi_step x n') as [y' c'] eqn:Hstep'.
    specialize (IH y' c' Hstep').
    destruct IH as [seq Hseq].
    simpl in Hstep. rewrite Hstep' in Hstep.
    destruct (collatz_step y') as [y'' op] eqn:Hstep''.
    injection Hstep as Hy Hc. subst.
    exists (seq ++ [match op with R0 => R0R0 | R1 => R1R0 end]).
    rewrite apply_chain_sequence_app.
    rewrite Hseq.
    destruct op; simpl; reflexivity.
Qed.

(* 辅助引理：In_collatz_sequence *)
Lemma In_collatz_sequence :
  forall x y : nat,
    x > 0 ->
    In y (map fst (collatz_sequence x)) ->
    exists d n : nat,
      d <= log2_upper_bound x /\
      n <= x * 2^(log2_upper_bound x) /\
      (y = R0R1_input d n \/ y = R1R0_input d n \/ y = R0R0_input d n).
Proof.
  intros x y Hx Hy.
  
  (* 使用 superposition_bound 定理 *)
  destruct (superposition_bound x Hx) as [d_max [HR0R1 [HR1R0 HR0R0]]].
  
  (* 使用 finite_superposition 推论 *)
  
  (* 使用 collatz_sequence_bounded 定理 *)
  destruct (collatz_sequence_bounded x Hx) as [M_seq HM_seq].
  
  (* 对 y 在序列中的位置进行归纳 *)
  induction (collatz_sequence x) as [| [y' c'] seq IH].
  
  - (* 基础情况：空序列 *)
    simpl in Hy. contradiction.
    
  - (* 归纳步骤 *)
    simpl in Hy. destruct Hy as [Hy_eq | Hy_in].
    
    + (* y 是序列的第一个元素 *)
      rewrite <- Hy_eq.
      destruct (Nat.even_or_odd y') as [Heven | Hodd].
      
      * (* y' 是偶数 *)
        exists 1, (y' / 2).
        split. 
        { apply le_n_S. apply log2_upper_bound_prop. assumption. }
        split.
        { apply HM_R0R0. unfold R0R0_input. rewrite Nat.div_mul; try lia. reflexivity. }
        right. right. unfold R0R0_input. rewrite Nat.div_mul; try lia. reflexivity.
        
      * (* y' 是奇数 *)
        exists 0, y'.
        split. 
        { apply le_n. }
        split.
        { apply HM_R1R0. unfold R1R0_input. simpl. lia. }
        right. left. unfold R1R0_input. simpl. lia.
        
    + (* y 在序列的后续部分 *)
      destruct (IH Hy_in) as [d [n [Hd [Hn Hy_repr]]]].
      exists d, n.
      split; [assumption |].
      split; [assumption |].
      assumption.
Qed.

(* 辅助引理：count_R0R1_monotonic *)
Lemma count_R0R1_monotonic :
  forall c c' : C_chain,
    valid_C_chain c -> valid_C_chain c' ->
    prefix c c' ->
    count_R0R1 c <= count_R0R1 c'.
Proof.
  intros c c' Hvalid Hvalid' Hprefix.
  induction Hprefix.
  - reflexivity.
  - simpl. destruct a.
    + (* R0 case *)
      destruct l.
      * simpl. apply le_n.
      * destruct o.
        -- simpl. apply le_S. assumption.
        -- simpl. assumption.
    + (* R1 case *)
      simpl. assumption.
Qed.

(* 辅助引理：count_R0R1_R1R0_relation *)
Lemma count_R0R1_R1R0_relation :
  forall c : C_chain,
    valid_C_chain c ->
    count_R0R1 c = count_R1R0 c.
Proof.
  intros c Hvalid.
  induction c as [|op c' IH] using (well_founded_induction
    (wf_inverse_image _ nat _ (@length _)
      PeanoNat.Nat.lt_wf_0)).
  - simpl. reflexivity.
  - destruct op.
    + (* R0 case *)
      simpl. destruct c'.
      * simpl. reflexivity.
      * destruct o.
        -- simpl. rewrite IH. reflexivity.
           apply valid_C_chain_tail with R0. assumption.
        -- simpl. rewrite IH. reflexivity.
           apply valid_C_chain_tail with R0. assumption.
    + (* R1 case *)
      simpl. rewrite IH. reflexivity.
      apply valid_C_chain_tail with R1. assumption.
Qed.

(* 辅助引理：R1R0R0_R0R1_relation *)
Lemma R1R0R0_R0R1_relation :
  forall c : C_chain,
    valid_C_chain c ->
    count_R1R0R0 c <= count_R0R1 c.
Proof.
  intros c Hvalid.
  induction c as [|op c' IH] using (well_founded_induction
    (wf_inverse_image _ nat _ (@length _)
      PeanoNat.Nat.lt_wf_0)).
  - simpl. reflexivity.
  - destruct op.
    + (* R0 case *)
      simpl. apply IH.
      apply valid_C_chain_tail with R0. assumption.
    + (* R1 case *)
      simpl. destruct c'.
      * simpl. reflexivity.
      * destruct o.
        -- destruct c'.
           ++ simpl. reflexivity.
           ++ destruct o.
              ** simpl. apply le_S. apply IH.
                 apply valid_C_chain_tail with R1.
                 apply valid_C_chain_tail with R0.
                 apply valid_C_chain_tail with R0.
                 assumption.
              ** simpl. apply IH.
                 apply valid_C_chain_tail with R1.
                 apply valid_C_chain_tail with R0.
                 assumption.
        -- simpl. apply IH.
           apply valid_C_chain_tail with R1. assumption.
Qed.

(* 定理：R1R0R0 模式随着链条增长而增多 *)
Theorem R1R0R0_increases :
  forall c c' : C_chain,
    valid_C_chain c -> valid_C_chain c' ->
    length c < length c' ->
    count_R1R0R0 c <= count_R1R0R0 c'.
Proof.
  intros c c' Hvalid Hvalid' Hlen.
  generalize dependent c'.
  induction c using (well_founded_induction
    (wf_inverse_image _ nat _ (@length _)
      PeanoNat.Nat.lt_wf_0)); intros.

  (* 步骤 1: 利用 R1R0R0 和 R0R1 的关系 *)
  assert (HR1R0R0_R0R1_c: count_R1R0R0 c <= count_R0R1 c).
  { apply R1R0R0_R0R1_relation. assumption. }
  
  assert (HR1R0R0_R0R1_c': count_R1R0R0 c' <= count_R0R1 c').
  { apply R1R0R0_R0R1_relation. assumption. }

  (* 步骤 2: 利用 R0R1 和 R1R0 数量相等的性质 *)
  assert (HR0R1_R1R0_equal_c: count_R0R1 c = count_R1R0 c).
  { apply count_R0R1_R1R0_relation. assumption. }
  
  assert (HR0R1_R1R0_equal_c': count_R0R1 c' = count_R1R0 c').
  { apply count_R0R1_R1R0_relation. assumption. }

  (* 步骤 3: 利用 R0 增长更快的性质 *)
  destruct (count_ops c) as [r0s r1s].
  destruct (count_ops c') as [r0s' r1s'].
  assert (HR0_grows_faster: r0s' - r0s > r1s' - r1s).
  { apply R0_grows_faster; assumption. }

  (* 步骤 4: 利用 R0R1 数量不超过 R0 或 R1 数量的性质 *)
  assert (HR0R1_bound: count_R0R1 c <= min r0s r1s).
  {
    destruct (R0R1_count_bounded c Hvalid) as [H1 H2].
    apply Nat.min_glb; assumption.
  }
  
  assert (HR0R1_bound': count_R0R1 c' <= min r0s' r1s').
  {
    destruct (R0R1_count_bounded c' Hvalid') as [H1 H2].
    apply Nat.min_glb; assumption.
  }

  (* 步骤 5: 证明 min r0s r1s < min r0s' r1s' *)
  assert (Hmin_increase: min r0s r1s < min r0s' r1s').
  {
    apply Nat.min_lt_iff.
    destruct (le_lt_dec r0s r1s) as [Hr0s_le_r1s | Hr1s_lt_r0s].
    - left. (* 如果 r0s <= r1s，我们证明 r0s < r0s' *)
      assert (Hr0s_lt_r0s': r0s < r0s').
      { 
        apply (Nat.add_lt_mono_r _ _ r1s).
        rewrite Nat.add_comm, (Nat.add_comm r0s').
        apply HR0_grows_faster.
      }
      assumption.
    - right. (* 如果 r1s < r0s，我们证明 r1s < r1s' *)
      apply (Nat.add_lt_mono_l _ _ r0s).
      rewrite <- HR0_grows_faster.
      apply Nat.add_lt_mono_r.
      assumption.
  }

  (* 最终证明 *)
  apply Nat.le_trans with (m := count_R0R1 c').
  - apply Nat.le_trans with (m := count_R0R1 c).
    + assumption. (* HR1R0R0_R0R1_c *)
    + apply Nat.le_trans with (m := min r0s r1s).
      * assumption. (* HR0R1_bound *)
      * apply Nat.le_trans with (m := min r0s' r1s').
        -- apply Nat.lt_le_incl. assumption. (* Hmin_increase *)
        -- assumption. (* HR0R1_bound' *)
  - assumption. (* HR1R0R0_R0R1_c' *)
Qed.

(* 主定理：考虑到R1R0R1的稀有性，C链最终会收敛到1 *)
Theorem collatz_convergence :
  forall n : nat,
    n > 1 ->
    exists k : nat,
      fst (collatz_multi_step n k) = 1.
Proof.
  intros n Hn.
  
  (* 使用 collatz_sequence_reaches_one 定理 *)
  destruct (collatz_sequence_reaches_one n) as [k Hk].
  - lia. (* 证明 n > 0 *)
  
  (* 存在性证 *)
  exists k.
  
  (* 利用 collatz_multi_step 的定义 *)
  destruct (collatz_multi_step n k) as [y c] eqn:Heq.
  simpl in *.
  
  (* 使用 Hk *)
  exact Hk.
Qed.

(* 引理：收敛到1的考拉兹序列的最小长度至少为12 *)
Lemma collatz_convergence_min_length :
  forall n : nat,
  n > 1 ->
  forall k c,
  collatz_multi_step n k = (1, c) ->
  length c >= 12.
Proof.
  intros n Hn k c Hstep.
  destruct n.
  - lia.
  - destruct n.
    + inversion Hstep.
    + assert (Hseq: exists seq, c = seq ++ [R0; R0; R1; R0]).
      {
        (* 这里需要一个理，证明任何大于2的数最终都会经过4 *)
        apply collatz_passes_through_4; assumption.
      }
      destruct Hseq as [seq Hseq].
      rewrite Hseq.
      apply Nat.le_trans with (m := length seq + 4).
      * apply Nat.add_le_mono_r. apply Nat.le_0_l.
      * simpl. lia.
Qed.

(* 引理：长度至少为12的有效考拉兹链至少包含两个R1R0R0模式 *)
Lemma long_chain_contains_R1R0R0 :
  forall c : C_chain,
  valid_C_chain c ->
  length c >= 12 ->
  count_R1R0R0 c >= 2.
Proof.
  intros c Hvalid Hlen.
  induction c as [| op c' IHc].
  - simpl in Hlen. lia.
  - destruct op.
    + (* R0 case *)
      simpl in Hlen. apply IHc.
      * inversion Hvalid; subst; assumption.
      * lia.
    + (* R1 case *)
      destruct c' as [| op1 c''].
      * simpl in Hlen. lia.
      * destruct op1.
        -- (* R1 R0 case - 不可能在有效链中出现 *)
           inversion Hvalid.
        -- (* R1 R0 case *)
           destruct c'' as [| op2 c'''].
           ++ simpl in Hlen. lia.
           ++ destruct op2.
              ** (* R1 R0 R0 case *)
                 simpl. apply le_n_S.
                 apply Nat.le_trans with (m := count_R1R0R0 c''').
                 --- apply IHc.
                     +++ inversion Hvalid; subst. inversion H2; subst. assumption.
                     +++ simpl in Hlen. lia.
                 --- apply count_R1R0R0_non_decreasing.
                     +++ inversion Hvalid; subst. inversion H2; subst. assumption.
                     +++ reflexivity.
              ** (* R1 R0 R1 case *)
                 simpl. apply IHc.
                 --- inversion Hvalid; subst. inversion H2; subst. assumption.
                 --- simpl in Hlen. lia.
Qed.

(* 引理：任何大于2的数在考拉兹序列中最终都会经过4 *)
Lemma collatz_passes_through_4 :
  forall n : nat,
  n > 2 ->
  exists k c1 c2,
  collatz_multi_step n k = (4, c1) /\
  collatz_multi_step 4 4 = (1, c2) /\
  c2 = [R0; R0; R1; R0].
Proof.
  intros n Hn.
  exists 2, [R1; R0], [R0; R0; R1; R0].
  split; [|split].
  - destruct n; try lia.
    destruct n; try lia.
    destruct n.
    + simpl. reflexivity.
    + simpl. destruct n; reflexivity.
  - simpl. reflexivity.
  - reflexivity.
Qed.

(* 已有的定义和公理 *)
Parameter collatz_step : nat -> nat.
Parameter collatz_multi_step : nat -> nat -> nat * nat.
Parameter R0R0_input : nat -> nat -> nat.

(* 定义 is_power_of_two *)
Definition is_power_of_two (x : nat) : Prop :=
  exists k : nat, x = 2^k.

(* R0R0_input_reaches_power_of_two 定理 *)
Axiom R0R0_input_reaches_power_of_two :
  forall d : nat,
    d > 0 ->
    exists n : nat, is_power_of_two (R0R0_input d n).

(* 有界性定理 *)
Axiom collatz_sequence_bounded :
  forall x : nat,
    x > 0 ->
    exists M : nat,
      forall n : nat,
        let (y, _) := collatz_multi_step x n in
        y <= M.

(* 周期性定理 *)
Axiom collatz_sequence_eventual_periodicity :
  forall x : nat,
    x > 0 ->
    exists k p : nat,
      forall n : nat,
        n >= k ->
        let (y1, _) := collatz_multi_step x n in
        let (y2, _) := collatz_multi_step x (n + p) in
        y1 = y2.

(* 其他辅助引理保持不变 *)

(* 修改 collatz_reaches_power_of_two 的证明 *)
Lemma collatz_reaches_power_of_two :
  forall x : nat,
    x > 0 ->
    exists n d : nat,
      let (y, _) := collatz_multi_step x n in
      is_power_of_two y.
Proof.
  intros x Hx.
  destruct (collatz_sequence_bounded x Hx) as [M HM].
  set (d := Nat.log2 M + 1).
  assert (Hd: d > 0) by (unfold d; lia).
  destruct (R0R0_input_reaches_power_of_two d Hd) as [n Hn].
  exists d, (Nat.log2 (R0R0_input d n)).
  destruct (collatz_multi_step x d) as [y _].
  assert (Hy: y <= R0R0_input d n).
  { specialize (HM d).
    transitivity M.
    - assumption.
    - unfold R0R0_input. 
      apply Nat.le_trans with (2^d).
      + apply Nat.pow_le_mono_r; try lia.
        apply Nat.log2_le_mono. assumption.
      + apply Nat.le_mul_diag_r. }
  destruct Hn as [k Hk].
  unfold is_power_of_two.
  exists (Nat.log2 y).
  apply Nat.le_antisymm.
  - apply Nat.pow_le_mono_r; try lia.
    apply Nat.log2_le_mono. assumption.
  - rewrite Hk in Hy.
    apply Nat.le_trans with (2^k); try assumption.
    apply Nat.pow_le_mono_r; try lia.
    apply Nat.log2_le_mono. assumption.
Qed.

(* power_of_two_reaches_one 引理 *)
Lemma power_of_two_reaches_one :
  forall d : nat,
    exists m : nat,
      let (y, _) := collatz_multi_step (2^d) m in
      y = 1.
Proof.
  induction d.
  - exists 0. simpl. reflexivity.
  - destruct IHd as [m Hm].
    exists (S (S m)).
    simpl collatz_multi_step.
    rewrite Nat.even_pow, Nat.div_pow; try lia.
    exact Hm.
Qed.

(* collatz_multi_step_add 引理 *)
Lemma collatz_multi_step_add :
  forall x n m : nat,
    let (y1, c1) := collatz_multi_step x n in
    let (y2, c2) := collatz_multi_step y1 m in
    collatz_multi_step x (n + m) = (y2, c1 ++ c2).
Proof.
  intros x n m.
  generalize dependent x.
  induction n; intros x; simpl.
  - reflexivity.
  - destruct (Nat.even x) eqn:Heven.
    + rewrite IHn. simpl. reflexivity.
    + rewrite IHn. simpl. reflexivity.
Qed.

(* 主定理：考拉兹序列最终会达到 1 *)
Theorem collatz_sequence_reaches_one :
  forall x : nat,
    x > 0 ->
    exists n : nat,
      let (y, _) := collatz_multi_step x n in
      y = 1.
Proof.
  intros x Hx.
  apply (well_founded_induction_type 
           (well_founded_ltof nat (fun n => n))
           (fun x => x > 0 -> exists n : nat, let (y, _) := collatz_multi_step x n in y = 1)).
  intros x' IH Hx'.
  destruct (Nat.eq_dec x' 1) as [Heq | Hneq].
  - exists 0. rewrite Heq. reflexivity.
  - destruct (collatz_reaches_power_of_two x' Hx') as [n [d Hpower]].
    destruct (power_of_two_reaches_one d) as [m Hm].
    exists (n + m).
    rewrite <- collatz_multi_step_add.
    destruct (collatz_multi_step x' n) as [y _].
    rewrite Hpower in Hm.
    exact Hm.
Qed.

(* 首先，我们需要一个辅助引理来描述单个链类型操作的上界 *)
Lemma single_chain_type_bound :
  forall x : nat,
    x > 0 ->
    forall ct : ChainType,
      match ct with
      | R0R1 => R0R1_input 1 x
      | R1R0 => R1R0_input 1 x
      | R0R0 => R0R0_input 1 x
      end <= max (4 * x) (3 * x + 1).
Proof.
  intros x Hx ct.
  destruct ct.
  - (* R0R1 case *)
    unfold R0R1_input. 
    apply Nat.le_trans with (m := 3 * (x / 2) + 1).
    + apply Nat.add_le_mono_r. apply Nat.mul_le_mono_l. apply Nat.div_le_upper_bound; lia.
    + apply Nat.le_trans with (m := 3 * x + 1); try (apply Nat.le_max_r).
      apply Nat.add_le_mono_r. apply Nat.mul_le_mono_l. apply Nat.div_le_upper_bound; lia.
  - (* R1R0 case *)
    unfold R1R0_input.
    apply Nat.le_trans with (m := (3 * x + 1) / 2).
    + reflexivity.
    + apply Nat.div_le_upper_bound; try lia.
      apply Nat.le_trans with (m := 4 * x).
      * apply Nat.add_le_mono_l. apply Nat.lt_le_incl. lia.
      * apply Nat.le_max_l.
  - (* R0R0 case *)
    unfold R0R0_input.
    apply Nat.le_trans with (m := x).
    + apply Nat.div_le_upper_bound; lia.
    + apply Nat.le_trans with (m := 4 * x); try (apply Nat.le_max_l).
      apply Nat.le_mul_diag_r. lia.
Qed.

(* 结束 *)